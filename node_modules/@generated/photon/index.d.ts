import { DMMF, DMMFClass, Engine } from './runtime';
/**
 * Utility Types
 */
export declare type Enumerable<T> = T | Array<T>;
export declare type MergeTruthyValues<R extends object, S extends object> = {
    [key in keyof S | keyof R]: key extends false ? never : key extends keyof S ? S[key] extends false ? never : S[key] : key extends keyof R ? R[key] : never;
};
export declare type CleanupNever<T> = {
    [key in keyof T]: T[key] extends never ? never : key;
}[keyof T];
/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PhotonFetcher {
    private readonly photon;
    private readonly engine;
    private readonly debug;
    private readonly hooks?;
    constructor(photon: Photon, engine: Engine, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, path?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}
/**
 * Client
**/
export declare type Datasources = {
    db?: string;
};
export interface PhotonOptions {
    datasources?: Datasources;
    debug?: boolean | {
        engine?: boolean;
        library?: boolean;
    };
    /**
     * You probably don't want to use this. `__internal` is used by internal tooling.
     */
    __internal?: {
        hooks?: Hooks;
        engine?: {
            cwd?: string;
            binaryPath?: string;
        };
    };
}
export declare type Hooks = {
    beforeRequest?: (options: {
        query: string;
        path: string[];
        rootField?: string;
        typeName?: string;
        document: any;
    }) => any;
};
export declare class Photon {
    private fetcher;
    private readonly dmmf;
    private readonly engine;
    private readonly datamodel;
    private connectionPromise?;
    constructor(options?: PhotonOptions);
    private connectEngine;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    readonly users: UserDelegate;
    readonly articles: ArticleDelegate;
    readonly categories: CategoryDelegate;
}
export declare const OrderByArg: {
    asc: "asc";
    desc: "desc";
};
export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg];
/**
 * Model User
 */
export declare type User = {
    id: string;
    firstname: string;
    lastname: string;
    email: string;
    password: string;
};
export declare type UserScalars = 'id' | 'firstname' | 'lastname' | 'email' | 'password';
export declare type UserSelect = {
    id?: boolean;
    firstname?: boolean;
    lastname?: boolean;
    email?: boolean;
    articles?: boolean | FindManyArticleSelectArgsOptional;
    password?: boolean;
};
export declare type UserInclude = {
    articles?: boolean | FindManyArticleIncludeArgsOptional;
};
declare type UserDefault = {
    id: true;
    firstname: true;
    lastname: true;
    email: true;
    password: true;
};
declare type UserGetSelectPayload<S extends boolean | UserSelect> = S extends true ? User : S extends UserSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends UserScalars ? User[P] : P extends 'articles' ? Array<ArticleGetSelectPayload<ExtractFindManyArticleSelectArgs<S[P]>> | null> : never;
} : never;
declare type UserGetIncludePayload<S extends boolean | UserInclude> = S extends true ? User : S extends UserInclude ? {
    [P in CleanupNever<MergeTruthyValues<UserDefault, S>>]: P extends UserScalars ? User[P] : P extends 'articles' ? Array<ArticleGetIncludePayload<ExtractFindManyArticleIncludeArgs<S[P]>> | null> : never;
} : never;
export interface UserDelegate {
    <T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    findOne<T extends FindOneUserArgs>(args: Subset<T, FindOneUserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneUserSelectArgs ? Promise<UserGetSelectPayload<ExtractFindOneUserSelectArgs<T>> | null> : T extends FindOneUserIncludeArgs ? Promise<UserGetIncludePayload<ExtractFindOneUserIncludeArgs<T>> | null> : UserClient<User | null>;
    findMany<T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    create<T extends UserCreateArgs>(args: Subset<T, UserCreateArgs>): T extends UserCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectCreateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectCreateArgs<T>>> : T extends UserIncludeCreateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeCreateArgs<T>>> : UserClient<User>;
    delete<T extends UserDeleteArgs>(args: Subset<T, UserDeleteArgs>): T extends UserDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectDeleteArgs ? Promise<UserGetSelectPayload<ExtractUserSelectDeleteArgs<T>>> : T extends UserIncludeDeleteArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeDeleteArgs<T>>> : UserClient<User>;
    update<T extends UserUpdateArgs>(args: Subset<T, UserUpdateArgs>): T extends UserUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpdateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpdateArgs<T>>> : T extends UserIncludeUpdateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpdateArgs<T>>> : UserClient<User>;
    deleteMany<T extends UserDeleteManyArgs>(args: Subset<T, UserDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends UserUpdateManyArgs>(args: Subset<T, UserUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends UserUpsertArgs>(args: Subset<T, UserUpsertArgs>): T extends UserUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpsertArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpsertArgs<T>>> : T extends UserIncludeUpsertArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpsertArgs<T>>> : UserClient<User>;
    count(): Promise<number>;
}
export declare class UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    articles<T extends FindManyArticleArgs = {}>(args?: Subset<T, FindManyArticleArgs>): T extends FindManyArticleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyArticleSelectArgs ? Promise<Array<ArticleGetSelectPayload<ExtractFindManyArticleSelectArgs<T>>>> : T extends FindManyArticleIncludeArgs ? Promise<Array<ArticleGetIncludePayload<ExtractFindManyArticleIncludeArgs<T>>>> : Promise<Array<Article>>;
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * User findOne
 */
export declare type FindOneUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractFindOneUserSelectArgs<S extends undefined | boolean | FindOneUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserSelectArgs ? S['select'] : true;
export declare type ExtractFindOneUserIncludeArgs<S extends undefined | boolean | FindOneUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserIncludeArgs ? S['include'] : true;
/**
 * User findMany
 */
export declare type FindManyUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgs = {
    select: UserSelect;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgsOptional = {
    select?: UserSelect | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgs = {
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyUserSelectArgs<S extends undefined | boolean | FindManyUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserSelectArgs ? S['select'] : true;
export declare type ExtractFindManyUserIncludeArgs<S extends undefined | boolean | FindManyUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserIncludeArgs ? S['include'] : true;
/**
 * User create
 */
export declare type UserCreateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type UserCreateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgs = {
    select: UserSelect;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgsOptional = {
    select?: UserSelect | null;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgs = {
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgsOptional = {
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type ExtractUserSelectCreateArgs<S extends undefined | boolean | UserSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectCreateArgs ? S['select'] : true;
export declare type ExtractUserIncludeCreateArgs<S extends undefined | boolean | UserIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeCreateArgs ? S['include'] : true;
/**
 * User update
 */
export declare type UserUpdateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserUpdateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgs = {
    select: UserSelect;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgsOptional = {
    select?: UserSelect | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgs = {
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgsOptional = {
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectUpdateArgs<S extends undefined | boolean | UserSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpdateArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpdateArgs<S extends undefined | boolean | UserIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpdateArgs ? S['include'] : true;
/**
 * User updateMany
 */
export declare type UserUpdateManyArgs = {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
/**
 * User upsert
 */
export declare type UserUpsertArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserUpsertArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type ExtractUserSelectUpsertArgs<S extends undefined | boolean | UserSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpsertArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpsertArgs<S extends undefined | boolean | UserIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpsertArgs ? S['include'] : true;
/**
 * User delete
 */
export declare type UserDeleteArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type UserDeleteArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectDeleteArgs<S extends undefined | boolean | UserSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectDeleteArgs ? S['select'] : true;
export declare type ExtractUserIncludeDeleteArgs<S extends undefined | boolean | UserIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeDeleteArgs ? S['include'] : true;
/**
 * User deleteMany
 */
export declare type UserDeleteManyArgs = {
    where?: UserWhereInput | null;
};
/**
 * User without action
 */
export declare type UserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
};
export declare type UserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
};
export declare type UserSelectArgs = {
    select: UserSelect;
};
export declare type UserSelectArgsOptional = {
    select?: UserSelect | null;
};
export declare type UserIncludeArgs = {
    include: UserInclude;
};
export declare type UserIncludeArgsOptional = {
    include?: UserInclude | null;
};
export declare type ExtractUserSelectArgs<S extends undefined | boolean | UserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectArgs ? S['select'] : true;
export declare type ExtractUserIncludeArgs<S extends undefined | boolean | UserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeArgs ? S['include'] : true;
/**
 * Model Article
 */
export declare type Article = {
    id: string;
    createdAt: Date;
    updatedAt: Date;
    title: string;
    url: string;
};
export declare type ArticleScalars = 'id' | 'createdAt' | 'updatedAt' | 'title' | 'url';
export declare type ArticleSelect = {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    title?: boolean;
    url?: boolean;
    creator?: boolean | FindManyUserSelectArgsOptional;
    categories?: boolean | FindManyCategorySelectArgsOptional;
};
export declare type ArticleInclude = {
    creator?: boolean | FindManyUserIncludeArgsOptional;
    categories?: boolean | FindManyCategoryIncludeArgsOptional;
};
declare type ArticleDefault = {
    id: true;
    createdAt: true;
    updatedAt: true;
    title: true;
    url: true;
};
declare type ArticleGetSelectPayload<S extends boolean | ArticleSelect> = S extends true ? Article : S extends ArticleSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends ArticleScalars ? Article[P] : P extends 'creator' ? Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<S[P]>> | null> : P extends 'categories' ? Array<CategoryGetSelectPayload<ExtractFindManyCategorySelectArgs<S[P]>> | null> : never;
} : never;
declare type ArticleGetIncludePayload<S extends boolean | ArticleInclude> = S extends true ? Article : S extends ArticleInclude ? {
    [P in CleanupNever<MergeTruthyValues<ArticleDefault, S>>]: P extends ArticleScalars ? Article[P] : P extends 'creator' ? Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<S[P]>> | null> : P extends 'categories' ? Array<CategoryGetIncludePayload<ExtractFindManyCategoryIncludeArgs<S[P]>> | null> : never;
} : never;
export interface ArticleDelegate {
    <T extends FindManyArticleArgs>(args?: Subset<T, FindManyArticleArgs>): T extends FindManyArticleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyArticleSelectArgs ? Promise<Array<ArticleGetSelectPayload<ExtractFindManyArticleSelectArgs<T>>>> : T extends FindManyArticleIncludeArgs ? Promise<Array<ArticleGetIncludePayload<ExtractFindManyArticleIncludeArgs<T>>>> : Promise<Array<Article>>;
    findOne<T extends FindOneArticleArgs>(args: Subset<T, FindOneArticleArgs>): T extends FindOneArticleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneArticleSelectArgs ? Promise<ArticleGetSelectPayload<ExtractFindOneArticleSelectArgs<T>> | null> : T extends FindOneArticleIncludeArgs ? Promise<ArticleGetIncludePayload<ExtractFindOneArticleIncludeArgs<T>> | null> : ArticleClient<Article | null>;
    findMany<T extends FindManyArticleArgs>(args?: Subset<T, FindManyArticleArgs>): T extends FindManyArticleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyArticleSelectArgs ? Promise<Array<ArticleGetSelectPayload<ExtractFindManyArticleSelectArgs<T>>>> : T extends FindManyArticleIncludeArgs ? Promise<Array<ArticleGetIncludePayload<ExtractFindManyArticleIncludeArgs<T>>>> : Promise<Array<Article>>;
    create<T extends ArticleCreateArgs>(args: Subset<T, ArticleCreateArgs>): T extends ArticleCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends ArticleSelectCreateArgs ? Promise<ArticleGetSelectPayload<ExtractArticleSelectCreateArgs<T>>> : T extends ArticleIncludeCreateArgs ? Promise<ArticleGetIncludePayload<ExtractArticleIncludeCreateArgs<T>>> : ArticleClient<Article>;
    delete<T extends ArticleDeleteArgs>(args: Subset<T, ArticleDeleteArgs>): T extends ArticleDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends ArticleSelectDeleteArgs ? Promise<ArticleGetSelectPayload<ExtractArticleSelectDeleteArgs<T>>> : T extends ArticleIncludeDeleteArgs ? Promise<ArticleGetIncludePayload<ExtractArticleIncludeDeleteArgs<T>>> : ArticleClient<Article>;
    update<T extends ArticleUpdateArgs>(args: Subset<T, ArticleUpdateArgs>): T extends ArticleUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends ArticleSelectUpdateArgs ? Promise<ArticleGetSelectPayload<ExtractArticleSelectUpdateArgs<T>>> : T extends ArticleIncludeUpdateArgs ? Promise<ArticleGetIncludePayload<ExtractArticleIncludeUpdateArgs<T>>> : ArticleClient<Article>;
    deleteMany<T extends ArticleDeleteManyArgs>(args: Subset<T, ArticleDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends ArticleUpdateManyArgs>(args: Subset<T, ArticleUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends ArticleUpsertArgs>(args: Subset<T, ArticleUpsertArgs>): T extends ArticleUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends ArticleSelectUpsertArgs ? Promise<ArticleGetSelectPayload<ExtractArticleSelectUpsertArgs<T>>> : T extends ArticleIncludeUpsertArgs ? Promise<ArticleGetIncludePayload<ExtractArticleIncludeUpsertArgs<T>>> : ArticleClient<Article>;
    count(): Promise<number>;
}
export declare class ArticleClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    creator<T extends FindManyUserArgs = {}>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    categories<T extends FindManyCategoryArgs = {}>(args?: Subset<T, FindManyCategoryArgs>): T extends FindManyCategoryArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyCategorySelectArgs ? Promise<Array<CategoryGetSelectPayload<ExtractFindManyCategorySelectArgs<T>>>> : T extends FindManyCategoryIncludeArgs ? Promise<Array<CategoryGetIncludePayload<ExtractFindManyCategoryIncludeArgs<T>>>> : Promise<Array<Category>>;
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * Article findOne
 */
export declare type FindOneArticleArgs = {
    select?: ArticleSelect | null;
    include?: ArticleInclude | null;
    where: ArticleWhereUniqueInput;
};
export declare type FindOneArticleArgsRequired = {
    select: ArticleSelect;
    include: ArticleInclude;
    where: ArticleWhereUniqueInput;
};
export declare type FindOneArticleSelectArgs = {
    select: ArticleSelect;
    where: ArticleWhereUniqueInput;
};
export declare type FindOneArticleSelectArgsOptional = {
    select?: ArticleSelect | null;
    where: ArticleWhereUniqueInput;
};
export declare type FindOneArticleIncludeArgs = {
    include: ArticleInclude;
    where: ArticleWhereUniqueInput;
};
export declare type FindOneArticleIncludeArgsOptional = {
    include?: ArticleInclude | null;
    where: ArticleWhereUniqueInput;
};
export declare type ExtractFindOneArticleSelectArgs<S extends undefined | boolean | FindOneArticleSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneArticleSelectArgs ? S['select'] : true;
export declare type ExtractFindOneArticleIncludeArgs<S extends undefined | boolean | FindOneArticleIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneArticleIncludeArgs ? S['include'] : true;
/**
 * Article findMany
 */
export declare type FindManyArticleArgs = {
    select?: ArticleSelect | null;
    include?: ArticleInclude | null;
    where?: ArticleWhereInput | null;
    orderBy?: ArticleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyArticleArgsRequired = {
    select: ArticleSelect;
    include: ArticleInclude;
    where?: ArticleWhereInput | null;
    orderBy?: ArticleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyArticleSelectArgs = {
    select: ArticleSelect;
    where?: ArticleWhereInput | null;
    orderBy?: ArticleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyArticleSelectArgsOptional = {
    select?: ArticleSelect | null;
    where?: ArticleWhereInput | null;
    orderBy?: ArticleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyArticleIncludeArgs = {
    include: ArticleInclude;
    where?: ArticleWhereInput | null;
    orderBy?: ArticleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyArticleIncludeArgsOptional = {
    include?: ArticleInclude | null;
    where?: ArticleWhereInput | null;
    orderBy?: ArticleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyArticleSelectArgs<S extends undefined | boolean | FindManyArticleSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyArticleSelectArgs ? S['select'] : true;
export declare type ExtractFindManyArticleIncludeArgs<S extends undefined | boolean | FindManyArticleIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyArticleIncludeArgs ? S['include'] : true;
/**
 * Article create
 */
export declare type ArticleCreateArgs = {
    select?: ArticleSelect | null;
    include?: ArticleInclude | null;
    data: ArticleCreateInput;
};
export declare type ArticleCreateArgsRequired = {
    select: ArticleSelect;
    include: ArticleInclude;
    data: ArticleCreateInput;
};
export declare type ArticleSelectCreateArgs = {
    select: ArticleSelect;
    data: ArticleCreateInput;
};
export declare type ArticleSelectCreateArgsOptional = {
    select?: ArticleSelect | null;
    data: ArticleCreateInput;
};
export declare type ArticleIncludeCreateArgs = {
    include: ArticleInclude;
    data: ArticleCreateInput;
};
export declare type ArticleIncludeCreateArgsOptional = {
    include?: ArticleInclude | null;
    data: ArticleCreateInput;
};
export declare type ExtractArticleSelectCreateArgs<S extends undefined | boolean | ArticleSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleSelectCreateArgs ? S['select'] : true;
export declare type ExtractArticleIncludeCreateArgs<S extends undefined | boolean | ArticleIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleIncludeCreateArgs ? S['include'] : true;
/**
 * Article update
 */
export declare type ArticleUpdateArgs = {
    select?: ArticleSelect | null;
    include?: ArticleInclude | null;
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleUpdateArgsRequired = {
    select: ArticleSelect;
    include: ArticleInclude;
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleSelectUpdateArgs = {
    select: ArticleSelect;
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleSelectUpdateArgsOptional = {
    select?: ArticleSelect | null;
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleIncludeUpdateArgs = {
    include: ArticleInclude;
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleIncludeUpdateArgsOptional = {
    include?: ArticleInclude | null;
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
};
export declare type ExtractArticleSelectUpdateArgs<S extends undefined | boolean | ArticleSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleSelectUpdateArgs ? S['select'] : true;
export declare type ExtractArticleIncludeUpdateArgs<S extends undefined | boolean | ArticleIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleIncludeUpdateArgs ? S['include'] : true;
/**
 * Article updateMany
 */
export declare type ArticleUpdateManyArgs = {
    data: ArticleUpdateManyMutationInput;
    where?: ArticleWhereInput | null;
};
/**
 * Article upsert
 */
export declare type ArticleUpsertArgs = {
    select?: ArticleSelect | null;
    include?: ArticleInclude | null;
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
};
export declare type ArticleUpsertArgsRequired = {
    select: ArticleSelect;
    include: ArticleInclude;
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
};
export declare type ArticleSelectUpsertArgs = {
    select: ArticleSelect;
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
};
export declare type ArticleSelectUpsertArgsOptional = {
    select?: ArticleSelect | null;
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
};
export declare type ArticleIncludeUpsertArgs = {
    include: ArticleInclude;
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
};
export declare type ArticleIncludeUpsertArgsOptional = {
    include?: ArticleInclude | null;
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
};
export declare type ExtractArticleSelectUpsertArgs<S extends undefined | boolean | ArticleSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleSelectUpsertArgs ? S['select'] : true;
export declare type ExtractArticleIncludeUpsertArgs<S extends undefined | boolean | ArticleIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleIncludeUpsertArgs ? S['include'] : true;
/**
 * Article delete
 */
export declare type ArticleDeleteArgs = {
    select?: ArticleSelect | null;
    include?: ArticleInclude | null;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleDeleteArgsRequired = {
    select: ArticleSelect;
    include: ArticleInclude;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleSelectDeleteArgs = {
    select: ArticleSelect;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleSelectDeleteArgsOptional = {
    select?: ArticleSelect | null;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleIncludeDeleteArgs = {
    include: ArticleInclude;
    where: ArticleWhereUniqueInput;
};
export declare type ArticleIncludeDeleteArgsOptional = {
    include?: ArticleInclude | null;
    where: ArticleWhereUniqueInput;
};
export declare type ExtractArticleSelectDeleteArgs<S extends undefined | boolean | ArticleSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleSelectDeleteArgs ? S['select'] : true;
export declare type ExtractArticleIncludeDeleteArgs<S extends undefined | boolean | ArticleIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleIncludeDeleteArgs ? S['include'] : true;
/**
 * Article deleteMany
 */
export declare type ArticleDeleteManyArgs = {
    where?: ArticleWhereInput | null;
};
/**
 * Article without action
 */
export declare type ArticleArgs = {
    select?: ArticleSelect | null;
    include?: ArticleInclude | null;
};
export declare type ArticleArgsRequired = {
    select: ArticleSelect;
    include: ArticleInclude;
};
export declare type ArticleSelectArgs = {
    select: ArticleSelect;
};
export declare type ArticleSelectArgsOptional = {
    select?: ArticleSelect | null;
};
export declare type ArticleIncludeArgs = {
    include: ArticleInclude;
};
export declare type ArticleIncludeArgsOptional = {
    include?: ArticleInclude | null;
};
export declare type ExtractArticleSelectArgs<S extends undefined | boolean | ArticleSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleSelectArgs ? S['select'] : true;
export declare type ExtractArticleIncludeArgs<S extends undefined | boolean | ArticleIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends ArticleIncludeArgs ? S['include'] : true;
/**
 * Model Category
 */
export declare type Category = {
    id: string;
    type: string;
};
export declare type CategoryScalars = 'id' | 'type';
export declare type CategorySelect = {
    id?: boolean;
    type?: boolean;
    articles?: boolean | FindManyArticleSelectArgsOptional;
};
export declare type CategoryInclude = {
    articles?: boolean | FindManyArticleIncludeArgsOptional;
};
declare type CategoryDefault = {
    id: true;
    type: true;
};
declare type CategoryGetSelectPayload<S extends boolean | CategorySelect> = S extends true ? Category : S extends CategorySelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends CategoryScalars ? Category[P] : P extends 'articles' ? Array<ArticleGetSelectPayload<ExtractFindManyArticleSelectArgs<S[P]>> | null> : never;
} : never;
declare type CategoryGetIncludePayload<S extends boolean | CategoryInclude> = S extends true ? Category : S extends CategoryInclude ? {
    [P in CleanupNever<MergeTruthyValues<CategoryDefault, S>>]: P extends CategoryScalars ? Category[P] : P extends 'articles' ? Array<ArticleGetIncludePayload<ExtractFindManyArticleIncludeArgs<S[P]>> | null> : never;
} : never;
export interface CategoryDelegate {
    <T extends FindManyCategoryArgs>(args?: Subset<T, FindManyCategoryArgs>): T extends FindManyCategoryArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyCategorySelectArgs ? Promise<Array<CategoryGetSelectPayload<ExtractFindManyCategorySelectArgs<T>>>> : T extends FindManyCategoryIncludeArgs ? Promise<Array<CategoryGetIncludePayload<ExtractFindManyCategoryIncludeArgs<T>>>> : Promise<Array<Category>>;
    findOne<T extends FindOneCategoryArgs>(args: Subset<T, FindOneCategoryArgs>): T extends FindOneCategoryArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneCategorySelectArgs ? Promise<CategoryGetSelectPayload<ExtractFindOneCategorySelectArgs<T>> | null> : T extends FindOneCategoryIncludeArgs ? Promise<CategoryGetIncludePayload<ExtractFindOneCategoryIncludeArgs<T>> | null> : CategoryClient<Category | null>;
    findMany<T extends FindManyCategoryArgs>(args?: Subset<T, FindManyCategoryArgs>): T extends FindManyCategoryArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyCategorySelectArgs ? Promise<Array<CategoryGetSelectPayload<ExtractFindManyCategorySelectArgs<T>>>> : T extends FindManyCategoryIncludeArgs ? Promise<Array<CategoryGetIncludePayload<ExtractFindManyCategoryIncludeArgs<T>>>> : Promise<Array<Category>>;
    create<T extends CategoryCreateArgs>(args: Subset<T, CategoryCreateArgs>): T extends CategoryCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends CategorySelectCreateArgs ? Promise<CategoryGetSelectPayload<ExtractCategorySelectCreateArgs<T>>> : T extends CategoryIncludeCreateArgs ? Promise<CategoryGetIncludePayload<ExtractCategoryIncludeCreateArgs<T>>> : CategoryClient<Category>;
    delete<T extends CategoryDeleteArgs>(args: Subset<T, CategoryDeleteArgs>): T extends CategoryDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends CategorySelectDeleteArgs ? Promise<CategoryGetSelectPayload<ExtractCategorySelectDeleteArgs<T>>> : T extends CategoryIncludeDeleteArgs ? Promise<CategoryGetIncludePayload<ExtractCategoryIncludeDeleteArgs<T>>> : CategoryClient<Category>;
    update<T extends CategoryUpdateArgs>(args: Subset<T, CategoryUpdateArgs>): T extends CategoryUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends CategorySelectUpdateArgs ? Promise<CategoryGetSelectPayload<ExtractCategorySelectUpdateArgs<T>>> : T extends CategoryIncludeUpdateArgs ? Promise<CategoryGetIncludePayload<ExtractCategoryIncludeUpdateArgs<T>>> : CategoryClient<Category>;
    deleteMany<T extends CategoryDeleteManyArgs>(args: Subset<T, CategoryDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends CategoryUpdateManyArgs>(args: Subset<T, CategoryUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends CategoryUpsertArgs>(args: Subset<T, CategoryUpsertArgs>): T extends CategoryUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends CategorySelectUpsertArgs ? Promise<CategoryGetSelectPayload<ExtractCategorySelectUpsertArgs<T>>> : T extends CategoryIncludeUpsertArgs ? Promise<CategoryGetIncludePayload<ExtractCategoryIncludeUpsertArgs<T>>> : CategoryClient<Category>;
    count(): Promise<number>;
}
export declare class CategoryClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    articles<T extends FindManyArticleArgs = {}>(args?: Subset<T, FindManyArticleArgs>): T extends FindManyArticleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyArticleSelectArgs ? Promise<Array<ArticleGetSelectPayload<ExtractFindManyArticleSelectArgs<T>>>> : T extends FindManyArticleIncludeArgs ? Promise<Array<ArticleGetIncludePayload<ExtractFindManyArticleIncludeArgs<T>>>> : Promise<Array<Article>>;
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * Category findOne
 */
export declare type FindOneCategoryArgs = {
    select?: CategorySelect | null;
    include?: CategoryInclude | null;
    where: CategoryWhereUniqueInput;
};
export declare type FindOneCategoryArgsRequired = {
    select: CategorySelect;
    include: CategoryInclude;
    where: CategoryWhereUniqueInput;
};
export declare type FindOneCategorySelectArgs = {
    select: CategorySelect;
    where: CategoryWhereUniqueInput;
};
export declare type FindOneCategorySelectArgsOptional = {
    select?: CategorySelect | null;
    where: CategoryWhereUniqueInput;
};
export declare type FindOneCategoryIncludeArgs = {
    include: CategoryInclude;
    where: CategoryWhereUniqueInput;
};
export declare type FindOneCategoryIncludeArgsOptional = {
    include?: CategoryInclude | null;
    where: CategoryWhereUniqueInput;
};
export declare type ExtractFindOneCategorySelectArgs<S extends undefined | boolean | FindOneCategorySelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneCategorySelectArgs ? S['select'] : true;
export declare type ExtractFindOneCategoryIncludeArgs<S extends undefined | boolean | FindOneCategoryIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneCategoryIncludeArgs ? S['include'] : true;
/**
 * Category findMany
 */
export declare type FindManyCategoryArgs = {
    select?: CategorySelect | null;
    include?: CategoryInclude | null;
    where?: CategoryWhereInput | null;
    orderBy?: CategoryOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCategoryArgsRequired = {
    select: CategorySelect;
    include: CategoryInclude;
    where?: CategoryWhereInput | null;
    orderBy?: CategoryOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCategorySelectArgs = {
    select: CategorySelect;
    where?: CategoryWhereInput | null;
    orderBy?: CategoryOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCategorySelectArgsOptional = {
    select?: CategorySelect | null;
    where?: CategoryWhereInput | null;
    orderBy?: CategoryOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCategoryIncludeArgs = {
    include: CategoryInclude;
    where?: CategoryWhereInput | null;
    orderBy?: CategoryOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyCategoryIncludeArgsOptional = {
    include?: CategoryInclude | null;
    where?: CategoryWhereInput | null;
    orderBy?: CategoryOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyCategorySelectArgs<S extends undefined | boolean | FindManyCategorySelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyCategorySelectArgs ? S['select'] : true;
export declare type ExtractFindManyCategoryIncludeArgs<S extends undefined | boolean | FindManyCategoryIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyCategoryIncludeArgs ? S['include'] : true;
/**
 * Category create
 */
export declare type CategoryCreateArgs = {
    select?: CategorySelect | null;
    include?: CategoryInclude | null;
    data: CategoryCreateInput;
};
export declare type CategoryCreateArgsRequired = {
    select: CategorySelect;
    include: CategoryInclude;
    data: CategoryCreateInput;
};
export declare type CategorySelectCreateArgs = {
    select: CategorySelect;
    data: CategoryCreateInput;
};
export declare type CategorySelectCreateArgsOptional = {
    select?: CategorySelect | null;
    data: CategoryCreateInput;
};
export declare type CategoryIncludeCreateArgs = {
    include: CategoryInclude;
    data: CategoryCreateInput;
};
export declare type CategoryIncludeCreateArgsOptional = {
    include?: CategoryInclude | null;
    data: CategoryCreateInput;
};
export declare type ExtractCategorySelectCreateArgs<S extends undefined | boolean | CategorySelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategorySelectCreateArgs ? S['select'] : true;
export declare type ExtractCategoryIncludeCreateArgs<S extends undefined | boolean | CategoryIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategoryIncludeCreateArgs ? S['include'] : true;
/**
 * Category update
 */
export declare type CategoryUpdateArgs = {
    select?: CategorySelect | null;
    include?: CategoryInclude | null;
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
};
export declare type CategoryUpdateArgsRequired = {
    select: CategorySelect;
    include: CategoryInclude;
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
};
export declare type CategorySelectUpdateArgs = {
    select: CategorySelect;
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
};
export declare type CategorySelectUpdateArgsOptional = {
    select?: CategorySelect | null;
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
};
export declare type CategoryIncludeUpdateArgs = {
    include: CategoryInclude;
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
};
export declare type CategoryIncludeUpdateArgsOptional = {
    include?: CategoryInclude | null;
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
};
export declare type ExtractCategorySelectUpdateArgs<S extends undefined | boolean | CategorySelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategorySelectUpdateArgs ? S['select'] : true;
export declare type ExtractCategoryIncludeUpdateArgs<S extends undefined | boolean | CategoryIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategoryIncludeUpdateArgs ? S['include'] : true;
/**
 * Category updateMany
 */
export declare type CategoryUpdateManyArgs = {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput | null;
};
/**
 * Category upsert
 */
export declare type CategoryUpsertArgs = {
    select?: CategorySelect | null;
    include?: CategoryInclude | null;
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
};
export declare type CategoryUpsertArgsRequired = {
    select: CategorySelect;
    include: CategoryInclude;
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
};
export declare type CategorySelectUpsertArgs = {
    select: CategorySelect;
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
};
export declare type CategorySelectUpsertArgsOptional = {
    select?: CategorySelect | null;
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
};
export declare type CategoryIncludeUpsertArgs = {
    include: CategoryInclude;
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
};
export declare type CategoryIncludeUpsertArgsOptional = {
    include?: CategoryInclude | null;
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
};
export declare type ExtractCategorySelectUpsertArgs<S extends undefined | boolean | CategorySelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategorySelectUpsertArgs ? S['select'] : true;
export declare type ExtractCategoryIncludeUpsertArgs<S extends undefined | boolean | CategoryIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategoryIncludeUpsertArgs ? S['include'] : true;
/**
 * Category delete
 */
export declare type CategoryDeleteArgs = {
    select?: CategorySelect | null;
    include?: CategoryInclude | null;
    where: CategoryWhereUniqueInput;
};
export declare type CategoryDeleteArgsRequired = {
    select: CategorySelect;
    include: CategoryInclude;
    where: CategoryWhereUniqueInput;
};
export declare type CategorySelectDeleteArgs = {
    select: CategorySelect;
    where: CategoryWhereUniqueInput;
};
export declare type CategorySelectDeleteArgsOptional = {
    select?: CategorySelect | null;
    where: CategoryWhereUniqueInput;
};
export declare type CategoryIncludeDeleteArgs = {
    include: CategoryInclude;
    where: CategoryWhereUniqueInput;
};
export declare type CategoryIncludeDeleteArgsOptional = {
    include?: CategoryInclude | null;
    where: CategoryWhereUniqueInput;
};
export declare type ExtractCategorySelectDeleteArgs<S extends undefined | boolean | CategorySelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategorySelectDeleteArgs ? S['select'] : true;
export declare type ExtractCategoryIncludeDeleteArgs<S extends undefined | boolean | CategoryIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategoryIncludeDeleteArgs ? S['include'] : true;
/**
 * Category deleteMany
 */
export declare type CategoryDeleteManyArgs = {
    where?: CategoryWhereInput | null;
};
/**
 * Category without action
 */
export declare type CategoryArgs = {
    select?: CategorySelect | null;
    include?: CategoryInclude | null;
};
export declare type CategoryArgsRequired = {
    select: CategorySelect;
    include: CategoryInclude;
};
export declare type CategorySelectArgs = {
    select: CategorySelect;
};
export declare type CategorySelectArgsOptional = {
    select?: CategorySelect | null;
};
export declare type CategoryIncludeArgs = {
    include: CategoryInclude;
};
export declare type CategoryIncludeArgsOptional = {
    include?: CategoryInclude | null;
};
export declare type ExtractCategorySelectArgs<S extends undefined | boolean | CategorySelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategorySelectArgs ? S['select'] : true;
export declare type ExtractCategoryIncludeArgs<S extends undefined | boolean | CategoryIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends CategoryIncludeArgs ? S['include'] : true;
/**
 * Deep Input Types
 */
export declare type CategoryWhereInput = {
    id?: string | StringFilter | null;
    type?: string | StringFilter | null;
    articles?: ArticleFilter | null;
    AND?: Enumerable<CategoryWhereInput> | null;
    OR?: Enumerable<CategoryWhereInput> | null;
    NOT?: Enumerable<CategoryWhereInput> | null;
};
export declare type ArticleWhereInput = {
    id?: string | StringFilter | null;
    createdAt?: Date | string | DateTimeFilter | null;
    updatedAt?: Date | string | DateTimeFilter | null;
    title?: string | StringFilter | null;
    url?: string | StringFilter | null;
    creator?: UserFilter | null;
    categories?: CategoryFilter | null;
    AND?: Enumerable<ArticleWhereInput> | null;
    OR?: Enumerable<ArticleWhereInput> | null;
    NOT?: Enumerable<ArticleWhereInput> | null;
};
export declare type UserWhereInput = {
    id?: string | StringFilter | null;
    firstname?: string | StringFilter | null;
    lastname?: string | StringFilter | null;
    email?: string | StringFilter | null;
    articles?: ArticleFilter | null;
    password?: string | StringFilter | null;
    AND?: Enumerable<UserWhereInput> | null;
    OR?: Enumerable<UserWhereInput> | null;
    NOT?: Enumerable<UserWhereInput> | null;
};
export declare type UserWhereUniqueInput = {
    id?: string | null;
};
export declare type ArticleWhereUniqueInput = {
    id?: string | null;
};
export declare type CategoryWhereUniqueInput = {
    id?: string | null;
    type?: string | null;
};
export declare type CategoryCreateWithoutArticlesInput = {
    id?: string | null;
    type: string;
};
export declare type CategoryCreateManyWithoutCategoriesInput = {
    create?: Enumerable<CategoryCreateWithoutArticlesInput> | null;
    connect?: Enumerable<CategoryWhereUniqueInput> | null;
};
export declare type ArticleCreateWithoutCreatorInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title: string;
    url: string;
    categories?: CategoryCreateManyWithoutCategoriesInput | null;
};
export declare type ArticleCreateManyWithoutArticlesInput = {
    create?: Enumerable<ArticleCreateWithoutCreatorInput> | null;
    connect?: Enumerable<ArticleWhereUniqueInput> | null;
};
export declare type UserCreateInput = {
    id?: string | null;
    firstname: string;
    lastname: string;
    email: string;
    password: string;
    articles?: ArticleCreateManyWithoutArticlesInput | null;
};
export declare type CategoryUpdateWithoutArticlesDataInput = {
    id?: string | null;
    type?: string | null;
};
export declare type CategoryUpdateWithWhereUniqueWithoutArticlesInput = {
    where: CategoryWhereUniqueInput;
    data: CategoryUpdateWithoutArticlesDataInput;
};
export declare type CategoryScalarWhereInput = {
    id?: string | StringFilter | null;
    type?: string | StringFilter | null;
    articles?: ArticleFilter | null;
    AND?: Enumerable<CategoryScalarWhereInput> | null;
    OR?: Enumerable<CategoryScalarWhereInput> | null;
    NOT?: Enumerable<CategoryScalarWhereInput> | null;
};
export declare type CategoryUpdateManyDataInput = {
    id?: string | null;
    type?: string | null;
};
export declare type CategoryUpdateManyWithWhereNestedInput = {
    where: CategoryScalarWhereInput;
    data: CategoryUpdateManyDataInput;
};
export declare type CategoryUpsertWithWhereUniqueWithoutArticlesInput = {
    where: CategoryWhereUniqueInput;
    update: CategoryUpdateWithoutArticlesDataInput;
    create: CategoryCreateWithoutArticlesInput;
};
export declare type CategoryUpdateManyWithoutArticlesInput = {
    create?: Enumerable<CategoryCreateWithoutArticlesInput> | null;
    connect?: Enumerable<CategoryWhereUniqueInput> | null;
    set?: Enumerable<CategoryWhereUniqueInput> | null;
    disconnect?: Enumerable<CategoryWhereUniqueInput> | null;
    delete?: Enumerable<CategoryWhereUniqueInput> | null;
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutArticlesInput> | null;
    updateMany?: Enumerable<CategoryUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<CategoryScalarWhereInput> | null;
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutArticlesInput> | null;
};
export declare type ArticleUpdateWithoutCreatorDataInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title?: string | null;
    url?: string | null;
    categories?: CategoryUpdateManyWithoutArticlesInput | null;
};
export declare type ArticleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ArticleWhereUniqueInput;
    data: ArticleUpdateWithoutCreatorDataInput;
};
export declare type ArticleScalarWhereInput = {
    id?: string | StringFilter | null;
    createdAt?: Date | string | DateTimeFilter | null;
    updatedAt?: Date | string | DateTimeFilter | null;
    title?: string | StringFilter | null;
    url?: string | StringFilter | null;
    creator?: UserFilter | null;
    categories?: CategoryFilter | null;
    AND?: Enumerable<ArticleScalarWhereInput> | null;
    OR?: Enumerable<ArticleScalarWhereInput> | null;
    NOT?: Enumerable<ArticleScalarWhereInput> | null;
};
export declare type ArticleUpdateManyDataInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title?: string | null;
    url?: string | null;
};
export declare type ArticleUpdateManyWithWhereNestedInput = {
    where: ArticleScalarWhereInput;
    data: ArticleUpdateManyDataInput;
};
export declare type ArticleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ArticleWhereUniqueInput;
    update: ArticleUpdateWithoutCreatorDataInput;
    create: ArticleCreateWithoutCreatorInput;
};
export declare type ArticleUpdateManyWithoutCreatorInput = {
    create?: Enumerable<ArticleCreateWithoutCreatorInput> | null;
    connect?: Enumerable<ArticleWhereUniqueInput> | null;
    set?: Enumerable<ArticleWhereUniqueInput> | null;
    disconnect?: Enumerable<ArticleWhereUniqueInput> | null;
    delete?: Enumerable<ArticleWhereUniqueInput> | null;
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutCreatorInput> | null;
    updateMany?: Enumerable<ArticleUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<ArticleScalarWhereInput> | null;
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutCreatorInput> | null;
};
export declare type UserUpdateInput = {
    id?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    email?: string | null;
    password?: string | null;
    articles?: ArticleUpdateManyWithoutCreatorInput | null;
};
export declare type UserUpdateManyMutationInput = {
    id?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    email?: string | null;
    password?: string | null;
};
export declare type UserCreateWithoutArticlesInput = {
    id?: string | null;
    firstname: string;
    lastname: string;
    email: string;
    password: string;
};
export declare type UserCreateManyWithoutCreatorInput = {
    create?: Enumerable<UserCreateWithoutArticlesInput> | null;
    connect?: Enumerable<UserWhereUniqueInput> | null;
};
export declare type ArticleCreateInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title: string;
    url: string;
    creator?: UserCreateManyWithoutCreatorInput | null;
    categories?: CategoryCreateManyWithoutCategoriesInput | null;
};
export declare type UserUpdateWithoutArticlesDataInput = {
    id?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    email?: string | null;
    password?: string | null;
};
export declare type UserUpdateWithWhereUniqueWithoutArticlesInput = {
    where: UserWhereUniqueInput;
    data: UserUpdateWithoutArticlesDataInput;
};
export declare type UserScalarWhereInput = {
    id?: string | StringFilter | null;
    firstname?: string | StringFilter | null;
    lastname?: string | StringFilter | null;
    email?: string | StringFilter | null;
    articles?: ArticleFilter | null;
    password?: string | StringFilter | null;
    AND?: Enumerable<UserScalarWhereInput> | null;
    OR?: Enumerable<UserScalarWhereInput> | null;
    NOT?: Enumerable<UserScalarWhereInput> | null;
};
export declare type UserUpdateManyDataInput = {
    id?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    email?: string | null;
    password?: string | null;
};
export declare type UserUpdateManyWithWhereNestedInput = {
    where: UserScalarWhereInput;
    data: UserUpdateManyDataInput;
};
export declare type UserUpsertWithWhereUniqueWithoutArticlesInput = {
    where: UserWhereUniqueInput;
    update: UserUpdateWithoutArticlesDataInput;
    create: UserCreateWithoutArticlesInput;
};
export declare type UserUpdateManyWithoutArticlesInput = {
    create?: Enumerable<UserCreateWithoutArticlesInput> | null;
    connect?: Enumerable<UserWhereUniqueInput> | null;
    set?: Enumerable<UserWhereUniqueInput> | null;
    disconnect?: Enumerable<UserWhereUniqueInput> | null;
    delete?: Enumerable<UserWhereUniqueInput> | null;
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutArticlesInput> | null;
    updateMany?: Enumerable<UserUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<UserScalarWhereInput> | null;
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutArticlesInput> | null;
};
export declare type ArticleUpdateInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title?: string | null;
    url?: string | null;
    creator?: UserUpdateManyWithoutArticlesInput | null;
    categories?: CategoryUpdateManyWithoutArticlesInput | null;
};
export declare type ArticleUpdateManyMutationInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title?: string | null;
    url?: string | null;
};
export declare type CategoryCreateInput = {
    id?: string | null;
    type: string;
    articles?: ArticleCreateManyWithoutArticlesInput | null;
};
export declare type ArticleCreateWithoutCategoriesInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title: string;
    url: string;
    creator?: UserCreateManyWithoutCreatorInput | null;
};
export declare type ArticleUpdateWithoutCategoriesDataInput = {
    id?: string | null;
    createdAt?: Date | string | null;
    updatedAt?: Date | string | null;
    title?: string | null;
    url?: string | null;
    creator?: UserUpdateManyWithoutArticlesInput | null;
};
export declare type ArticleUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ArticleWhereUniqueInput;
    data: ArticleUpdateWithoutCategoriesDataInput;
};
export declare type ArticleUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ArticleWhereUniqueInput;
    update: ArticleUpdateWithoutCategoriesDataInput;
    create: ArticleCreateWithoutCategoriesInput;
};
export declare type ArticleUpdateManyWithoutCategoriesInput = {
    create?: Enumerable<ArticleCreateWithoutCategoriesInput> | null;
    connect?: Enumerable<ArticleWhereUniqueInput> | null;
    set?: Enumerable<ArticleWhereUniqueInput> | null;
    disconnect?: Enumerable<ArticleWhereUniqueInput> | null;
    delete?: Enumerable<ArticleWhereUniqueInput> | null;
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutCategoriesInput> | null;
    updateMany?: Enumerable<ArticleUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<ArticleScalarWhereInput> | null;
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutCategoriesInput> | null;
};
export declare type CategoryUpdateInput = {
    id?: string | null;
    type?: string | null;
    articles?: ArticleUpdateManyWithoutCategoriesInput | null;
};
export declare type CategoryUpdateManyMutationInput = {
    id?: string | null;
    type?: string | null;
};
export declare type StringFilter = {
    equals?: string | null;
    not?: string | StringFilter | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string | null;
    lte?: string | null;
    gt?: string | null;
    gte?: string | null;
    contains?: string | null;
    startsWith?: string | null;
    endsWith?: string | null;
};
export declare type ArticleFilter = {
    every?: ArticleWhereInput | null;
    some?: ArticleWhereInput | null;
    none?: ArticleWhereInput | null;
};
export declare type DateTimeFilter = {
    equals?: Date | string | null;
    not?: Date | string | DateTimeFilter | null;
    in?: Enumerable<Date | string> | null;
    notIn?: Enumerable<Date | string> | null;
    lt?: Date | string | null;
    lte?: Date | string | null;
    gt?: Date | string | null;
    gte?: Date | string | null;
};
export declare type UserFilter = {
    every?: UserWhereInput | null;
    some?: UserWhereInput | null;
    none?: UserWhereInput | null;
};
export declare type CategoryFilter = {
    every?: CategoryWhereInput | null;
    some?: CategoryWhereInput | null;
    none?: CategoryWhereInput | null;
};
export declare type UserOrderByInput = {
    id?: OrderByArg | null;
    firstname?: OrderByArg | null;
    lastname?: OrderByArg | null;
    email?: OrderByArg | null;
    password?: OrderByArg | null;
};
export declare type ArticleOrderByInput = {
    id?: OrderByArg | null;
    createdAt?: OrderByArg | null;
    updatedAt?: OrderByArg | null;
    title?: OrderByArg | null;
    url?: OrderByArg | null;
};
export declare type CategoryOrderByInput = {
    id?: OrderByArg | null;
    type?: OrderByArg | null;
};
/**
 * Batch Payload for updateMany & deleteMany
 */
export declare type BatchPayload = {
    count: number;
};
/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
